Arithmetic with R

All the normal operators apply with the addition of 

    Exponentation ^ = Raises the power of the number on the left by the number on the right

    Modulo %% = returns the remainder of the division of the number to the left by the number on the right

#######################################################################################################################
Variable assignment: 

    my_var <- 4

#######################################################################################################################
Basic Data Types in R:

    Numerics = Decimal Values like 4.5
    Intergers = whole numbers like 4
    Logical = TRUE/FALSE                        # Note that these are always in all CAPS
    characters = text / string

########################################################################################################################
Checking the Data Type: 

    class() = will check what data type a variable Intergers

########################################################################################################################
Create a Vector:

    A vector is a 1D array that can hold numeric, character, or logical data

    c() = is the command to create a vector, place the elements between the () separated by comas

    example: 
        numeric_vector = c(1,2,3)
        character_vector = c("a", "b", "c")
        boolean_vector = c(TRUE, FALSE, TRUE)

###########################################################################################################################
Naming a Vector: 

    names() = the command to name a vector

    example: names each element in roulette_vector with a corisponding day of the week
        roulette_vector <- c(-24, -50, 100, -350, 10)
        names(roulette_vector) <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday") # you can also assign the days of the week to a variable and use it

#############################################################################################################################
Calculate Total Winnings:

    sum() = calculates the sum of all elements in a vector

    example:
        total_poker <- sum(poker_vector)

#############################################################################################################################
Selecting Elements in a Vector:

    example:
    # It seems that R indexes start from 1 not 0
    my_vector[1]

    example: 
    # selects the first and fifth elements
    poker_vector[c(1,5)]

    example: 
    # selects elements 2-4 including 4
    poker_vector[c(2:4)]

    example: 
    # if you have named your elements you can select them by name
    poker_vector[c("Monday", "Tuesday")]

##########################################################################################################################
Calculating The average of values

    mean() = calculates the average of the the values given to it

    example:
    poker_start <- poker_vector[c("Monday", "Tuesday", "Wednesday")
    mean(poker_start)]

##########################################################################################################################
Comparison operators

    < = less than
    > = Greater than
    <= = Less than or equal to 
    >= = Greater than or equal to 
    == = equal to each other
    != = Not equal to each other

    example:
    selection_vector <- poker_vector > 0    # creates a boolean array
    poker_winning_days <- poker_vector[selection_vector]    # This will only select elements that are true and assign the values

###########################################################################################################################
Advanced Selection:

    example:
    selection_vector <- roulette_vector > 0
    roulette_winning_days <- roulette_vector[selection_vector]

###########################################################################################################################
Matrix:

    matrix() = collection of elements of the same data type arranged in a fixed number of rows and columns which is a 2D array

    example:
    # 1:9 is shortcut for making a vector with content 1-9
    # byrow = TRUE means the martix will be filled by row if you want to fill by column then set to FALSE
    # nrow = 3 sets the row count to 3 
    matrix(1:9, byrow = True, nrow = 3)

Analyzing Matrices:

###########################################################################################################################
Factors:

    The term factor refers to a statistical data type used to store categorical variables. The difference between a categorical variable and a continuous variable is that a categorical variable can belong to a limited number of categories. A continuous variable, on the other hand, can correspond to an infinite number of values.

It is important that R knows whether it is dealing with a continuous or a categorical variable, as the statistical models you will develop in the future treat both types differently. (You will see later why this is the case.)

A good example of a categorical variable is sex. In many circumstances you can limit the sex categories to "Male" or "Female".
 (Sometimes you may need different categories. For example, you may need to consider chromosomal variation, hermaphroditic 
 animals, or different cultural norms, but you will always have a finite number of categories.)

 To create factors in R, you make use of the function factor(). First thing that you have to do is create a vector that 
 contains all the observations that belong to a limited number of categories. For example, sex_vector contains the sex of 5 
 different individuals:

sex_vector <- c("Male","Female","Female","Male","Male")
It is clear that there are two categories, or in R-terms 'factor levels', at work here: "Male" and "Female".

The function factor() will encode the vector as a factor:

factor_sex_vector <- factor(sex_vector)

What's a factor and why would you use it? (3)
There are two types of categorical variables: a nominal categorical variable and an ordinal categorical variable.

A nominal variable is a categorical variable without an implied order. This means that it is impossible to say that 
'one is worth more than the other'. For example, think of the categorical variable animals_vector with the categories 
"Elephant", "Giraffe", "Donkey" and "Horse". Here, it is impossible to say that one stands above or below the other. 
(Note that some of you might disagree ;-) ).

In contrast, ordinal variables do have a natural ordering. Consider for example the categorical variable temperature_vector 
with the categories: "Low", "Medium" and "High". Here it is obvious that "Medium" stands above "Low", and "High" stands 
above "Medium".

Factor levels
When you first get a dataset, you will often notice that it contains factors with specific factor levels. However, 
sometimes you will want to change the names of these levels for clarity or other reasons. R allows you to do this with the 
function levels():

levels(factor_vector) <- c("name1", "name2",...)

A good illustration is the raw data that is provided to you by a survey. A common question for every questionnaire is the 
sex of the respondent. Here, for simplicity, just two categories were recorded, "M" and "F". (You usually need more categories
 for survey data; either way, you use a factor to store the categorical data.)

survey_vector <- c("M", "F", "F", "M", "M")

Recording the sex with the abbreviations "M" and "F" can be convenient if you are collecting data with pen and paper, 
but it can introduce confusion when analyzing the data. At that point, you will often want to change the factor levels to 
"Male" and "Female" instead of "M" and "F" for clarity.

Watch out: the order with which you assign the levels is important. If you type levels(factor_survey_vector), you'll see 
that it outputs [1] "F" "M". If you don't specify the levels of the factor when creating the vector, R will automatically 
assign them alphabetically. To correctly map "F" to "Female" and "M" to "Male", the levels should be set to 
c("Female", "Male"), in this order.

Summarizing a factor
After finishing this course, one of your favorite functions in R will be summary(). This will give you a quick overview 
of the contents of a variable:

summary(my_var)

Going back to our survey, you would like to know how many "Male" responses you have in your study, and how many 
"Female" responses. The summary() function gives you the answer to this question.

You might wonder what happens when you try to compare elements of a factor. In factor_survey_vector you have a factor
 with two levels: "Male" and "Female". But how does R value these relative to each other?

 example:
    # Read the code in the editor and submit the answer to test if male is greater than (>) female.

    # Build factor_survey_vector with clean levels
    survey_vector <- c("M", "F", "F", "M", "M")
    factor_survey_vector <- factor(survey_vector)
    levels(factor_survey_vector) <- c("Female", "Male")

    # Male
    male <- factor_survey_vector[1]

    # Female
    female <- factor_survey_vector[2]

    # Battle of the sexes: Male 'larger' than female?
    male > female

Ordered Factors: 

Since "Male" and "Female" are unordered (or nominal) factor levels, R returns a warning message, telling you that the 
greater than operator is not meaningful. As seen before, R attaches an equal value to the levels for such factors.

But this is not always the case! Sometimes you will also deal with factors that do have a natural ordering between its 
categories. If this is the case, we have to make sure that we pass this information to R…

Let us say that you are leading a research team of five data analysts and that you want to evaluate their performance. 
To do this, you track their speed, evaluate each analyst as "slow", "medium" or "fast", and save the results in 
speed_vector.

speed_vector should be converted to an ordinal factor since its categories have a natural ordering. By default, the 
function factor() transforms speed_vector into an unordered factor. To create an ordered factor, you have to add two 
additional arguments: ordered and levels.

factor(some_vector,
       ordered = TRUE,
       levels = c("lev1", "lev2" ...))

By setting the argument ordered to TRUE in the function factor(), you indicate that the factor is ordered. With the
 argument levels you give the values of the factor in the correct order.

    example: 
    # Create speed_vector
    speed_vector <- c("medium", "slow", "slow", "medium", "fast")

    # Convert speed_vector to ordered factor vector
    factor_speed_vector <- factor(speed_vector, ordered = TRUE, c("slow", "medium", "fast"))

    # Print factor_speed_vector
    factor_speed_vector
    summary(factor_speed_vector)

Comparing ordered factors
Having a bad day at work, 'data analyst number two' enters your office and starts complaining that 'data analyst number five' 
is slowing down the entire project. Since you know that 'data analyst number two' has the reputation of being a smarty-pants, 
you first decide to check if his statement is true.

The fact that factor_speed_vector is now ordered enables us to compare different elements (the data analysts in this case). 
You can simply do this by using the well-known operators.

    example:
    # Create factor_speed_vector
    speed_vector <- c("medium", "slow", "slow", "medium", "fast")
    factor_speed_vector <- factor(speed_vector, ordered = TRUE, levels = c("slow", "medium", "fast"))

    # Factor value for second data analyst
    da2 <- factor_speed_vector[2]

    # Factor value for fifth data analyst
    da5 <- factor_speed_vector[5]

    # Is data analyst 2 faster than data analyst 5?
    da2 > da5

###########################################################################################################################
Dataframes:

What's a data frame?
You may remember from the chapter about matrices that all the elements that you put in a matrix should be of the same type. 
Back then, your dataset on Star Wars only contained numeric elements.

When doing a market research survey, however, you often have questions such as:

'Are you married?' or 'yes/no' questions (logical)
'How old are you?' (numeric)
'What is your opinion on this product?' or other 'open-ended' questions (character)
…
The output, namely the respondents' answers to the questions formulated above, is a dataset of different data types. You will 
often find yourself working with datasets that contain different data types instead of only one.

A data frame has the variables of a dataset as columns and the observations as rows. This will be a familiar concept for 
those coming from different statistical software packages such as SAS or SPSS.

Quick, have a look at your dataset
Wow, that is a lot of cars!

Working with large datasets is not uncommon in data analysis. When you work with (extremely) large datasets and data frames, 
your first task as a data analyst is to develop a clear understanding of its structure and main elements. Therefore, it is 
often useful to show only a small part of the entire dataset.

So how to do this in R? Well, the function head() enables you to show the first observations of a data frame. Similarly, the 
function tail() prints out the last observations in your dataset.

Both head() and tail() print a top line called the 'header', which contains the names of the different variables in your 
dataset.

Have a look at the structure
Another method that is often used to get a rapid overview of your data is the function str(). The function str() shows you 
the structure of your dataset. For a data frame it tells you:

The total number of observations (e.g. 32 car types)
The total number of variables (e.g. 11 car features)
A full list of the variables names (e.g. mpg, cyl … )
The data type of each variable (e.g. num)
The first observations
Applying the str() function will often be the first thing that you do when receiving a new dataset or data frame. It is a
great way to get more insight in your dataset before diving into the real analysis.

Creating a data frame
Since using built-in datasets is not even half the fun of creating your own datasets, the rest of this chapter is based on 
your personally developed dataset. Put your jet pack on because it is time for some space exploration!

As a first goal, you want to construct a data frame that describes the main characteristics of eight planets in our solar 
system. According to your good friend Buzz, the main features of a planet are:

The type of planet (Terrestrial or Gas Giant).
The planet's diameter relative to the diameter of the Earth.
The planet's rotation across the sun relative to that of the Earth.
If the planet has rings or not (TRUE or FALSE).
After doing some high-quality research on Wikipedia, you feel confident enough to create the necessary vectors: name, type, 
diameter, rotation and rings; these vectors have already been coded up in the editor. The first element in each of these 
vectors correspond to the first observation.

You construct a data frame with the data.frame() function. As arguments, you pass the vectors from before: they will become 
the different columns of your data frame. Because every column has the same length, the vectors you pass should also have the 
same length. But don't forget that it is possible (and likely) that they contain different types of data.

    Example:
    # Definition of vectors
    name <- c("Mercury", "Venus", "Earth", 
            "Mars", "Jupiter", "Saturn", 
            "Uranus", "Neptune")
    type <- c("Terrestrial planet", 
            "Terrestrial planet", 
            "Terrestrial planet", 
            "Terrestrial planet", "Gas giant", 
            "Gas giant", "Gas giant", "Gas giant")
    diameter <- c(0.382, 0.949, 1, 0.532, 
                11.209, 9.449, 4.007, 3.883)
    rotation <- c(58.64, -243.02, 1, 1.03, 
                0.41, 0.43, -0.72, 0.67)
    rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

    # Create a data frame from the vectors
    planets_df <- data.frame(name, type, diameter, rotation, rings)

Selection of data frame elements
Similar to vectors and matrices, you select elements from a data frame with the help of square brackets [ ]. By using a 
comma, you can indicate what to select from the rows and the columns respectively. For example:

my_df[1,2] selects the value at the first row and second column in my_df.
my_df[1:3,2:4] selects rows 1, 2, 3 and columns 2, 3, 4 in my_df.

Sometimes you want to select all elements of a row or column. For example, my_df[1, ] selects all elements of the first row. 
Let us now apply this technique on planets_df!

    Example:
    # The planets_df data frame from the previous exercise is pre-loaded

    # Print out diameter of Mercury (row 1, column 3)
    planets_df[1,3]

    # Print out data for Mars (entire fourth row)
    planets_df[4,]

Selection of data frame elements (2)
Instead of using numerics to select elements of a data frame, you can also use the variable names to select columns of a 
data frame.

Suppose you want to select the first three elements of the type column. One way to do this is

planets_df[1:3,2]

A possible disadvantage of this approach is that you have to know (or look up) the column number of type, which gets hard if 
you have a lot of variables. It is often easier to just make use of the variable name:

planets_df[1:3,"type"]

    Example:
    # The planets_df data frame from the previous exercise is pre-loaded

    # Select first 5 values of diameter column
    planets_df[1:5, "diameter"]

Only planets with rings
You will often want to select an entire column, namely one specific variable from a data frame. If you want to select all 
elements of the variable diameter, for example, both of these will do the trick:

planets_df[,3]
planets_df[,"diameter"]

However, there is a short-cut. If your columns have names, you can use the $ sign:

planets_df$diameter

    Example:
    # planets_df is pre-loaded in your workspace

    # Select the rings variable from planets_df
    rings_vector <- planets_df$rings
    
    # Print out rings_vector
    rings_vector

Only planets with rings (2)
You probably remember from high school that some planets in our solar system have rings and others do not. Unfortunately you 
can not recall their names. Could R help you out?

If you type rings_vector in the console, you get:

[1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE

This means that the first four observations (or planets) do not have a ring (FALSE), but the other four do (TRUE). However, 
you do not get a nice overview of the names of these planets, their diameter, etc. Let's try to use rings_vector to select 
the data for the four planets with rings.

    Example:
    # planets_df and rings_vector are pre-loaded in your workspace

    # Adapt the code to select all columns for planets with rings
    planets_df[rings_vector, ]

Only planets with rings but shorter
So what exactly did you learn in the previous exercises? You selected a subset from a data frame (planets_df) based on 
whether or not a certain condition was true (rings or no rings), and you managed to pull out all relevant data. Pretty 
awesome! By now, NASA is probably already flirting with your CV ;-).

Now, let us move up one level and use the function subset(). You should see the subset() function as a short-cut to do 
exactly the same as what you did in the previous exercises.

subset(my_df, subset = some_condition)

The first argument of subset() specifies the dataset for which you want a subset. By adding the second argument, you give R 
the necessary information and conditions to select the correct subset.

The code below will give the exact same result as you got in the previous exercise, but this time, you didn't need the 
rings_vector!

subset(planets_df, subset = rings)

    Example:
    # planets_df is pre-loaded in your workspace

    # Select planets with diameter < 1
    subset(planets_df, subset = diameter < 1)

###########################################################################################################################
Sorting: 

Making and creating rankings is one of mankind's favorite affairs. These rankings can be useful (best universities in the 
world), entertaining (most influential movie stars) or pointless (best 007 look-a-like).

In data analysis you can sort your data according to a certain variable in the dataset. In R, this is done with the help of 
the function order().

order() is a function that gives you the ranked position of each element when it is applied on a variable, such as a vector 
for example:

a <- c(100, 10, 1000)
order(a)
[1] 2 1 3

10, which is the second element in a, is the smallest element, so 2 comes first in the output of order(a). 100, which is the 
first element in a is the second smallest element, so 1 comes second in the output of order(a).

This means we can use the output of order(a) to reshuffle a:

a[order(a)]
[1]   10  100 1000

Sorting your data frame
Alright, now that you understand the order() function, let us do something useful with it. You would like to rearrange your 
data frame such that it starts with the smallest planet and ends with the largest one. A sort on the diameter column.

    Example: 
    # planets_df is pre-loaded in your workspace

    # Use order() to create positions
    positions <-  order(planets_df$diameter)

    # Use positions to sort planets_df
    planets_df[positions,]

########################################################################################################################
Lists:

Lists, why would you need them?
Congratulations! At this point in the course you are already familiar with:

Vectors (one dimensional array): can hold numeric, character or logical values. The elements in a vector all have the same 
data type.
Matrices (two dimensional array): can hold numeric, character or logical values. The elements in a matrix all have the same 
data type.
Data frames (two-dimensional objects): can hold numeric, character or logical values. Within a column all elements have the 
same data type, but different columns can be of different data type.

Pretty sweet for an R newbie, right? ;-)

Lists, why would you need them? (2)
A list in R is similar to your to-do list at work or school: the different items on that list most likely differ in length, 
characteristic, and type of activity that has to be done.

A list in R allows you to gather a variety of objects under one name (that is, the name of the list) in an ordered way. These 
objects can be matrices, vectors, data frames, even other lists, etc. It is not even required that these objects are related 
to each other in any way.

You could say that a list is some kind super data type: you can store practically any piece of information in it!

Creating a list
Let us create our first list! To construct a list you use the function list():

my_list <- list(comp1, comp2 ...)

The arguments to the list function are the list components. Remember, these components can be matrices, vectors, other lists, …

    Example:
    # Vector with numerics from 1 up to 10
    my_vector <- 1:10 

    # Matrix with numerics from 1 up to 9
    my_matrix <- matrix(1:9, ncol = 3)

    # First 10 elements of the built-in data frame mtcars
    my_df <- mtcars[1:10,]

    # Construct list with these different elements:
    my_list <- list(my_vector, my_matrix, my_df)

Creating a named list
Well done, you're on a roll!

Just like on your to-do list, you want to avoid not knowing or remembering what the components of your list stand for. 
That is why you should give names to them:

my_list <- list(name1 = your_comp1, 
                name2 = your_comp2)

This creates a list with components that are named name1, name2, and so on. If you want to name your lists after you've 
created them, you can use the names() function as you did with vectors. The following commands are fully equivalent to the 
assignment above:

my_list <- list(your_comp1, your_comp2)
names(my_list) <- c("name1", "name2")

    Example: 
    # Vector with numerics from 1 up to 10
    my_vector <- 1:10 

    # Matrix with numerics from 1 up to 9
    my_matrix <- matrix(1:9, ncol = 3)

    # First 10 elements of the built-in data frame mtcars
    my_df <- mtcars[1:10,]

    # Adapt list() call to give the components names
    my_list <- list("vec" = my_vector, "mat" = my_matrix, "df" =my_df)


    # Print out my_list
    my_list

Creating a named list (2)
Being a huge movie fan (remember your job at LucasFilms), you decide to start storing information on good movies with the 
help of lists.

Start by creating a list for the movie "The Shining". We have already created the variables mov, act and rev in your R 
workspace. Feel free to check them out in the console.

    Example:
    # The variables mov, act and rev are available

    # Finish the code to build shining_list
    shining_list <- list(moviename = mov, actors = act, reviews = rev)

Selecting elements from a list
Your list will often be built out of numerous elements and components. Therefore, getting a single element, multiple 
elements, or a component out of it is not always straightforward.

One way to select a component is using the numbered position of that component. For example, to "grab" the first component 
of shining_list you type

shining_list[[1]]

A quick way to check this out is typing it in the console. Important to remember: to select elements from vectors, you use 
single square brackets: [ ]. Don't mix them up!

You can also refer to the names of the components, with [[ ]] or with the $ sign. Both will select the data frame 
representing the reviews:

shining_list[["reviews"]]
shining_list$reviews
Besides selecting components, you often need to select specific elements out of these components. For example, with 
shining_list[[2]][1] you select from the second component, actors (shining_list[[2]]), the first element ([1]). When 
you type this in the console, you will see the answer is Jack Nicholson.

    Example:
    # shining_list is already pre-loaded in the workspace

    # Print out the vector representing the actors
    shining_list$actors

    # Print the second element of the vector representing the actors
    shining_list[[2]][2]

Creating a new list for another movie
You found reviews of another, more recent, Jack Nicholson movie: The Departed!

Scores	        Comments
4.6	            I would watch it again
5	            Amazing!
4.8	            I liked it
5	            One of the best movies
4.2	            Fascinating plot

It would be useful to collect together all the pieces of information about the movie, like the title, actors, and reviews 
into a single variable. Since these pieces of data are different shapes, it is natural to combine them in a list variable.

movie_title, containing the title of the movie, and movie_actors, containing the names of some of the actors in the movie, 
are available in your workspace.

    Example:
    # Use the table from the exercise to define the comments and scores vectors
    scores <- c(4.6, 5, 4.8, 5, 4.2)
    comments <- c("I would watch it again", "Amazing!", "I liked it", "One of the best movies", "Fascinating plot")

    # Save the average of the scores vector as avg_review
    avg_review <- mean(scores)

    # Combine scores and comments into the reviews_df data frame
    reviews_df <- data.frame(scores, comments)

    # Create and print out a list, called departed_list
    departed_list <- list(movie_title, movie_actors, reviews_df, avg_review)
    departed_list

##########################################################################################################################
Functions:

Before even thinking of using an R function, you should clarify which arguments it expects. All the relevant details such 
as a description, usage, and arguments can be found in the documentation. To consult the documentation on the sample() 
function, for example, you can use one of following R commands:

help(sample)

?sample

If you execute these commands, you'll be redirected to www.rdocumentation.org.

A quick hack to see the arguments of the sample() function is the args() function. Try it out in the console:

args(sample)
In the next exercises, you'll be learning how to use the mean() function with increasing complexity. The first thing you'll 
have to do is get acquainted with the mean() function.

    Example:
    # Consult the documentation on the mean() function
    ?mean

    # Inspect the arguments of the mean() function
    args(mean)

Use a function
The documentation on the mean() function gives us quite some information:

The mean() function computes the arithmetic mean.
The most general method takes multiple arguments: x and ....
The x argument should be a vector containing numeric, logical or time-related information.
Remember that R can match arguments both by position and by name. Can you still remember the difference? You'll find out 
in this exercise!

Once more, you'll be working with the view counts of your social network profiles for the past 7 days. These are stored 
in the linkedin and facebook vectors and have already been created for you.

    Example:
    # The linkedin and facebook vectors have already been created for you
    linkedin <- c(16, 9, 13, 5, 2, 17, 14)
    facebook <- c(17, 7, 5, 16, 8, 13, 14)

    # Calculate average number of views
    avg_li <- mean(linkedin)
    avg_fb <- mean(facebook)

    # Inspect avg_li and avg_fb
    print(avg_li)
    print(avg_fb)

Use a function (2)
Check the documentation on the mean() function again:

?mean
The Usage section of the documentation includes two versions of the mean() function. The first usage,

mean(x, ...)
is the most general usage of the mean function. The 'Default S3 method', however, is:

mean(x, trim = 0, na.rm = FALSE, ...)
The ... is called the ellipsis. It is a way for R to pass arguments along without the function having to name them explicitly. 
The ellipsis will be treated in more detail in future courses.

For the remainder of this exercise, just work with the second usage of the mean function. Notice that both trim and na.rm 
have default values. This makes them optional arguments.

    Example:
    # The linkedin and facebook vectors have already been created for you
    linkedin <- c(16, 9, 13, 5, 2, 17, 14)
    facebook <- c(17, 7, 5, 16, 8, 13, 14)

    # Calculate the mean of the sum
    avg_sum <- mean(linkedin + facebook)

    # Calculate the trimmed mean of the sum
    avg_sum_trimmed <- mean(linkedin + facebook, trim = 0.2)

    # Inspect both new variables
    print(avg_sum)
    print(avg_sum_trimmed)

Use a function (3)
In the video, Filip guided you through the example of specifying arguments of the sd() function. The sd() function has an 
optional argument, na.rm that specified whether or not to remove missing values from the input vector before calculating 
the standard deviation.

If you've had a good look at the documentation, you'll know by now that the mean() function also has this argument, na.rm, 
and it does the exact same thing. By default, it is set to FALSE, as the Usage of the default S3 method shows:

mean(x, trim = 0, na.rm = FALSE, ...)

Let's see what happens if your vectors linkedin and facebook contain missing values (NA).

    Example:
    # The linkedin and facebook vectors have already been created for you
    linkedin <- c(16, 9, 13, 5, NA, 17, 14)
    facebook <- c(17, NA, 5, 16, 8, 13, 14)

    # Basic average of linkedin
    mean(linkedin)

    # Advanced average of linkedin
    mean(linkedin, na.rm = TRUE)

Functions inside functions
You already know that R functions return objects that you can then use somewhere else. This makes it easy to use functions 
inside functions, as you've seen before:

speed <- 31
print(paste("Your speed is", speed))

Notice that both the print() and paste() functions use the ellipsis - ... - as an argument. Can you figure out how they're 
used?

    Example:
    # The linkedin and facebook vectors have already been created for you
    linkedin <- c(16, 9, 13, 5, NA, 17, 14)
    facebook <- c(17, NA, 5, 16, 8, 13, 14)

    # Calculate the mean absolute deviation
    mean(abs(linkedin - facebook), na.rm = TRUE)

Required, or optional?
By now, you will probably have a good understanding of the difference between required and optional arguments. Let's refresh 
this difference by having one last look at the mean() function:

mean(x, trim = 0, na.rm = FALSE, ...)

x is required; if you do not specify it, R will throw an error. trim and na.rm are optional arguments: they have a default value which is used if the arguments are not explicitly specified.

Which of the following statements about the read.table() function are true?

header, sep and quote are all optional arguments.
row.names and fileEncoding don't have default values.
read.table("myfile.txt", "-", TRUE) will throw an error.
read.table("myfile.txt", sep = "-", header = TRUE) will throw an error.

##########################################################################################################################
Writing Functions: 

Syntax:
my_function <- function(art1, arg2) {
    body of the function
}

Write your own function
Wow, things are getting serious… you're about to write your own function! Before you have a go at it, have a look at the 
following function template:

my_fun <- function(arg1, arg2) {
  body
}

Notice that this recipe uses the assignment operator (<-) just as if you were assigning a vector to a variable for example. 
This is not a coincidence. Creating a function in R basically is the assignment of a function object to a variable! In the 
recipe above, you're creating a new R variable my_fun, that becomes available in the workspace as soon as you execute the 
definition. From then on, you can use the my_fun as a function.

    Example:
    # Create a function pow_two()
    pow_two <- function(a) {
        a * a
    }


    # Use the function
    pow_two(12)

    # Create a function sum_abs()
    sum_abs <- function(a,b){
        abs(a) + abs(b)
    }


    # Use the function
    sum_abs(-2, 3)

Write your own function (2)
There are situations in which your function does not require an input. Let's say you want to write a function that gives us 
the random outcome of throwing a fair die:

throw_die <- function() {
  number <- sample(1:6, size = 1)
  number
}

throw_die()

Up to you to code a function that doesn't take any arguments!

    Example:
    # Define the function hello()
    hello <- function(){
        print("Hi there!")
        return(TRUE)
    }




    # Call the function hello()
    hello()

Write your own function (3)
Do you still remember the difference between an argument with and without default values? The usage section in the sd() 
documentation shows the following information:

sd(x, na.rm = FALSE)

This tells us that x has to be defined for the sd() function to be called correctly, however, na.rm already has a default 
value. Not specifying this argument won't cause an error.

You can define default argument values in your own R functions as well. You can use the following recipe to do so:

my_fun <- function(arg1, arg2 = val2) {
  body
}

The editor on the right already includes an extended version of the pow_two() function from before. Can you finish it?

    Example: 
    # Finish the pow_two() function
    pow_two <- function(x, print_info = TRUE) {
    y <- x ^ 2
    if(print_info == TRUE){
        print(paste(x, "to the power two equals", y))
    }
    return(y)
    }

Function scoping
An issue that Filip did not discuss in the video is function scoping. It implies that variables that are defined inside a function are not accessible outside that function. Try running the following code and see if you understand the results:

pow_two <- function(x) {
  y <- x ^ 2
  return(y)
}
pow_two(4)
y
x

y was defined inside the pow_two() function and therefore it is not accessible outside of that function. This is also true 
for the function's arguments of course - x in this case.

Which statement is correct about the following chunk of code? The function two_dice() is already available in the workspace.

two_dice <- function() {
  possibilities <- 1:6
  dice1 <- sample(possibilities, size = 1)
  dice2 <- sample(possibilities, size = 1)
  dice1 + dice2
}

R passes arguments by value
The title gives it away already: R passes arguments by value. What does this mean? Simply put, it means that an R function 
cannot change the variable that you input to that function. Let's look at a simple example (try it in the console):

triple <- function(x) {
  x <- 3*x
  x
}
a <- 5
triple(a)
a

Inside the triple() function, the argument x gets overwritten with its value times three. Afterwards this new x is returned. 
If you call this function with a variable a set equal to 5, you obtain 15. But did the value of a change? If R were to pass a 
to triple() by reference, the override of the x inside the function would ripple through to the variable a, outside the 
function. However, R passes by value, so the R objects you pass to a function can never change unless you do an explicit 
assignment. a remains equal to 5, even after calling triple(a).

Can you tell which one of the following statements is false about the following piece of code?

increment <- function(x, inc = 1) {
  x <- x + inc
  x
}
count <- 5
a <- increment(count, 2)
b <- increment(count)
count <- increment(count, 2)

R you functional?
Now that you've acquired some skills in defining functions with different types of arguments and return values, you should 
try to create more advanced functions. As you've noticed in the previous exercises, it's perfectly possible to add 
control-flow constructs, loops and even other functions to your function body.

Remember our social media example? The vectors linkedin and facebook are already defined in the workspace so you can get your 
hands dirty straight away. As a first step, you will be writing a function that can interpret a single value of this vector. 
In the next exercise, you will write another function that can handle an entire vector at once.

    Example:
    # The linkedin and facebook vectors have already been created for you

    # Define the interpret function
    interpret <- function(num_views) {
        if (num_views > 15) {
            print("You're popular!")
            return(num_views)
        } else {
            print("Try to be more visible!")
            return(0)
        }
    }

    # Call the interpret function twice
    interpret(linkedin[1])
    interpret(facebook[2])

R you functional? (2)
A possible implementation of the interpret() function has been provided for you. In this exercise you'll be writing another 
function that will use the interpret() function to interpret all the data from your daily profile views inside a vector. 
Furthermore, your function will return the sum of views on popular days, if asked for. A for loop is ideal for iterating 
over all the vector elements. The ability to return the sum of views on popular days is something you can code through a 
function argument with a default value.

    Example:
    # The linkedin and facebook vectors have already been created for you
    linkedin <- c(16, 9, 13, 5, 2, 17, 14)
    facebook <- c(17, 7, 5, 16, 8, 13, 14)

    # The interpret() can be used inside interpret_all()
    interpret <- function(num_views) {
        if (num_views > 15) {
            print("You're popular!")
            return(num_views)
        } else {
            print("Try to be more visible!")
            return(0)
        }
    }

    # Define the interpret_all() function
    # views: vector with data to interpret
    # return_sum: return total number of views on popular days?
    interpret_all <- function(views, return_sum = TRUE) {
        count <- 0

        for (v in views) {
            count = count + interpret(v)
        }

        if (return_sum == TRUE) {
            return(count)
        } else {
            return(NULL)
        }
    }

    # Call the interpret_all() function on both linkedin and facebook
    interpret_all(linkedin)
    interpret_all(facebook)

##########################################################################################################################
R Packages:

Load an R Package
There are basically two extremely important functions when it comes down to R packages:

install.packages(), which as you can expect, installs a given package.
library() which loads packages, i.e. attaches them to the search list on your R workspace.
To install packages, you need administrator privileges. This means that install.packages() will thus not work in the 
DataCamp interface. However, almost all CRAN packages are installed on our servers. You can load them with library().

In this exercise, you'll be learning how to load the ggplot2 package, a powerful package for data visualization. You'll 
use it to create a plot of two variables of the mtcars data frame. The data has already been prepared for you in the 
workspace.

Before starting, execute the following commands in the console:

search(), to look at the currently attached packages and
qplot(mtcars$wt, mtcars$hp), to build a plot of two variables of the mtcars data frame.
An error should occur, because you haven't loaded the ggplot2 package yet!

    Example:
    # Load the ggplot2 package
    library(ggplot2)

    # Retry the qplot() function
    qplot(mtcars$wt, mtcars$hp)

    # Check out the currently attached packages again
    search()

Different ways to load a package
The library() and require() functions are not very picky when it comes down to argument types: both library(rjson) and 
library("rjson") work perfectly fine for loading a package.

Have a look at some more code chunks that (attempt to) load one or more packages:

# Chunk 1
library(data.table)
require(rjson)

# Chunk 2
library("data.table")
require(rjson)

# Chunk 3
library(data.table)
require(rjson, character.only = TRUE)

# Chunk 4
library(c("data.table", "rjson"))
Select the option that lists all of the chunks that do not generate an error. The console is yours to experiment in.

####################################################################################################################
Lapply:

Before you go about solving the exercises below, have a look at the documentation of the lapply() function. The Usage 
section shows the following expression:

lapply(X, FUN, ...)

To put it generally, lapply takes a vector or list X, and applies the function FUN to each of its members. If FUN 
requires additional arguments, you pass them after you've specified X and FUN (...). The output of lapply() is a list, 
the same length as X, where each element is the result of applying FUN on the corresponding element of X.

Now that you are truly brushing up on your data science skills, let's revisit some of the most relevant figures in 
data science history. We've compiled a vector of famous mathematicians/statisticians and the year they were born. Up 
to you to extract some information!

    Example: 
    # The vector pioneers has already been created for you
    pioneers <- c("GAUSS:1777", "BAYES:1702", "PASCAL:1623", "PEARSON:1857")

    # Split names from birth year
    split_math <- strsplit(pioneers, split = ":")

    # Convert to lowercase strings: split_low
    split_low <- lapply(split_math, tolower)

    # Take a look at the structure of split_low
    str(split_low)

Use lapply with your own function
As Filip explained in the instructional video, you can use lapply() on your own functions as well. You just need to code a new function and 
make sure it is available in the workspace. After that, you can use the function inside lapply() just as you did with 
base R functions.

In the previous exercise you already used lapply() once to convert the information about your favorite pioneering 
statisticians to a list of vectors composed of two character strings. Let's write some code to select the names and 
the birth years separately.

The sample code already includes code that defined select_first(), that takes a vector as input and returns the first 
element of this vector.

    Example: 
    # Code from previous exercise:
    pioneers <- c("GAUSS:1777", "BAYES:1702", "PASCAL:1623", "PEARSON:1857")
    split <- strsplit(pioneers, split = ":")
    split_low <- lapply(split, tolower)

    # Write function select_first()
    select_first <- function(x) {
        x[1]
    }

    # Apply select_first() over split_low: names
    names <- lapply(split_low, select_first)

    # Write function select_second()
    select_second <- function(x) {
        x[2]
    }



    # Apply select_second() over split_low: years
    years <- lapply(split_low, select_second)

lapply and anonymous functions
Writing your own functions and then using them inside lapply() is quite an accomplishment! But defining functions to 
use them only once is kind of overkill, isn't it? That's why you can use so-called anonymous functions in R.

Previously, you learned that functions in R are objects in their own right. This means that they aren't automatically 
bound to a name. When you create a function, you can use the assignment operator to give the function a name. It's 
perfectly possible, however, to not give the function a name. This is called an anonymous function:

# Named function
triple <- function(x) { 3 * x }

# Anonymous function with same implementation
function(x) { 3 * x }

# Use anonymous function inside lapply()
lapply(list(1,2,3), function(x) { 3 * x })

split_low is defined for you.

    Example:
    # split_low has been created for you
    split_low

    # Transform: use anonymous function inside lapply
    names <- lapply(split_low, function(x) {x[1]})

    # Transform: use anonymous function inside lapply
    years <- lapply(split_low, function(x) {x[2]})

Use lapply with additional arguments
In the video, the triple() function was transformed to the multiply() function to allow for a more generic approach. 
lapply() provides a way to handle functions that require more than one argument, such as the multiply() function:

multiply <- function(x, factor) {
  x * factor
}

lapply(list(1,2,3), multiply, factor = 3)
On the right we've included a generic version of the select functions that you've coded earlier: select_el(). It 
takes a vector as its first argument, and an index as its second argument. It returns the vector's element at the 
specified index.

    Example:
    # Definition of split_low
    pioneers <- c("GAUSS:1777", "BAYES:1702", "PASCAL:1623", "PEARSON:1857")
    split <- strsplit(pioneers, split = ":")
    split_low <- lapply(split, tolower)

    # Generic select function
    select_el <- function(x, index) {
        x[index]
    }

    # Use lapply() twice on split_low: names and years
    names <- lapply(split_low, select_el, 1)
    years <- lapply(split_low, select_el, 2)

Apply functions that return NULL
In all of the previous exercises, it was assumed that the functions that were applied over vectors and lists actually 
returned a meaningful result. For example, the tolower() function simply returns the strings with the characters in 
lowercase. This won't always be the case. Suppose you want to display the structure of every element of a list. You 
could use the str() function for this, which returns NULL:

lapply(list(1, "a", TRUE), str)
This call actually returns a list, the same size as the input list, containing all NULL values. On the other hand 
calling

str(TRUE)
on its own prints only the structure of the logical to the console, not NULL. That's because str() uses invisible() 
behind the scenes, which returns an invisible copy of the return value, NULL in this case. This prevents it from being 
printed when the result of str() is not assigned.

What will the following code chunk return (split_low is already available in the workspace)? Try to reason about the 
result before simply executing it in the console!

lapply(split_low, function(x) {
  if (nchar(x[1]) > 5) {
    return(NULL)
  } else {
    return(x[2])
  }
})

###################################################################################################################
Sapply:

How to use sapply
You can use sapply() similar to how you used lapply(). The first argument of sapply() is the list or vector X over 
which you want to apply a function, FUN. Potential additional arguments to this function are specified afterwards 
(...):

sapply(X, FUN, ...)
In the next couple of exercises, you'll be working with the variable temp, that contains temperature measurements for 
7 days. temp is a list of length 7, where each element is a vector of length 5, representing 5 measurements on a given 
day. This variable has already been defined in the workspace: type str(temp) to see its structure.

    Example:
    # temp has already been defined in the workspace

    # Use lapply() to find each day's minimum temperature
    lapply(temp, min)

    # Use sapply() to find each day's minimum temperature
    sapply(temp, min)

    # Use lapply() to find each day's maximum temperature
    lapply(temp, max)

    # Use sapply() to find each day's maximum temperature
    sapply(temp, max)

sapply with your own function
Like lapply(), sapply() allows you to use self-defined functions and apply them over a vector or a list:

sapply(X, FUN, ...)

Here, FUN can be one of R's built-in functions, but it can also be a function you wrote. This self-written function 
can be defined before hand, or can be inserted directly as an anonymous function.

    Example:
    # temp is already defined in the workspace

    # Finish function definition of extremes_avg
    extremes_avg <- function(x) {
        ( min(x) + max(x) ) / 2
    }

    # Apply extremes_avg() over temp using sapply()
    sapply(temp, extremes_avg)

    # Apply extremes_avg() over temp using lapply()
    lapply(temp, extremes_avg)

sapply with function returning vector
In the previous exercises, you've seen how sapply() simplifies the list that lapply() would return by turning it into 
a vector. But what if the function you're applying over a list or a vector returns a vector of length greater than 1? 
If you don't remember from the video, don't waste more time in the valley of ignorance and head over to the 
instructions!

    Example: 
    # temp is already available in the workspace

    # Create a function that returns min and max of a vector: extremes
    extremes <- function(x) {
        c(min = min(x), max = max(x))
    }

    # Apply extremes() over temp with sapply()
    sapply(temp, extremes)

    # Apply extremes() over temp with lapply()
    lapply(temp, extremes)

sapply can't simplify, now what?
It seems like we've hit the jackpot with sapply(). On all of the examples so far, sapply() was able to nicely simplify 
the rather bulky output of lapply(). But, as with life, there are things you can't simplify. How does sapply() react?

We already created a function, below_zero(), that takes a vector of numerical values and returns a vector that only 
contains the values that are strictly below zero.

    Example:
    # temp is already prepared for you in the workspace

    # Definition of below_zero()
    below_zero <- function(x) {
        return(x[x < 0])
    }

    # Apply below_zero over temp using sapply(): freezing_s
    freezing_s <- sapply(temp, below_zero)

    # Apply below_zero over temp using lapply(): freezing_l
    freezing_l <- lapply(temp, below_zero)

    # Are freezing_s and freezing_l identical?
    identical(freezing_s, freezing_l)

sapply with functions that return NULL
You already have some apply tricks under your sleeve, but you're surely hungry for some more, aren't you? In this 
exercise, you'll see how sapply() reacts when it is used to apply a function that returns NULL over a vector or a 
list.

A function print_info(), that takes a vector and prints the average of this vector, has already been created for you. 
It uses the cat() function.

    Example:
    # temp is already available in the workspace

    # Definition of print_info()
    print_info <- function(x) {
        cat("The average temperature is", mean(x), "\n")
    }

    # Apply print_info() over temp using sapply()
    sapply(temp, print_info)

    # Apply print_info() over temp using lapply()
    lapply(temp, print_info)

Reverse engineering sapply

sapply(list(runif (10), runif (10)), 
       function(x) c(min = min(x), mean = mean(x), max = max(x)))

Without going straight to the console to run the code, try to reason through which of the following statements are 
correct and why.

(1) sapply() can't simplify the result that lapply() would return, and thus returns a list of vectors.
(2) This code generates a matrix with 3 rows and 2 columns.
(3) The function that is used inside sapply() is anonymous.
(4) The resulting data structure does not contain any names.

Select the option that lists all correct statements.

###################################################################################################################
Vapply:

Use vapply
Before you get your hands dirty with the third and last apply function that you'll learn about in this intermediate R 
course, let's take a look at its syntax. The function is called vapply(), and it has the following syntax:

vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)

Over the elements inside X, the function FUN is applied. The FUN.VALUE argument expects a template for the return 
argument of this function FUN. USE.NAMES is TRUE by default; in this case vapply() tries to generate a named array, 
if possible.

For the next set of exercises, you'll be working on the temp list again, that contains 7 numerical vectors of length 5. 
We also coded a function basics() that takes a vector, and returns a named vector of length 3, containing the minimum, 
mean and maximum value of the vector respectively.

    Example:
    # temp is already available in the workspace

    # Definition of basics()
    basics <- function(x) {
        c(min = min(x), mean = mean(x), max = max(x))
    }

    # Apply basics() over temp using vapply()
    vapply(temp, basics, numeric(3))

Use vapply (2)
So far you've seen that vapply() mimics the behavior of sapply() if everything goes according to plan. But what if it 
doesn't?

In the video, Filip showed you that there are cases where the structure of the output of the function you want to 
apply, FUN, does not correspond to the template you specify in FUN.VALUE. In that case, vapply() will throw an error 
that informs you about the misalignment between expected and actual output.

    Example: 
    # Incorrect code
    # temp is already available in the workspace

    # Definition of the basics() function
    basics <- function(x) {
        c(min = min(x), mean = mean(x), median = median(x), max = max(x))
    }

    # Fix the error:
    vapply(temp, basics, numeric(3))

    # result
    # temp is already available in the workspace
    # Definition of the basics() function
    basics <- function(x) {
        c(min = min(x), mean = mean(x), median = median(x), max = max(x))
    }
    # Fix the error:
    vapply(temp, basics, numeric(3))
    Error: values must be length 3,
    but FUN(X[[1]]) result is length 

    # Fixed Code
    # temp is already available in the workspace

    # Definition of the basics() function
    basics <- function(x) {
        c(min = min(x), mean = mean(x), median = median(x), max = max(x))
    }

    # Fix the error:
    vapply(temp, basics, numeric(4))

From sapply to vapply
As highlighted before, vapply() can be considered a more robust version of sapply(), because you explicitly restrict 
the output of the function you want to apply. Converting your sapply() expressions in your own R scripts to vapply() 
expressions is therefore a good practice (and also a breeze!).

    Example:
    # temp is already defined in the workspace

    # Convert to vapply() expression
    # sapply(temp, max)
    vapply(temp, max, numeric(1))

    # Convert to vapply() expression
    # sapply(temp, function(x, y) { mean(x) > y }, y = 5)
    vapply(temp, function(x, y) { mean(x) > y }, logical(1), y = 5)

####################################################################################################################
Useful Functions:

Mathematical utilities
Have another look at some useful math functions that R features:

abs(): Calculate the absolute value.
sum(): Calculate the sum of all the values in a data structure.
mean(): Calculate the arithmetic mean.
round(): Round the values to 0 decimal places by default. Try out ?round in the console for variations of round() and 
ways to change the number of digits to round to.
As a data scientist in training, you've estimated a regression model on the sales data for the past six months. After 
evaluating your model, you see that the training error of your model is quite regular, showing both positive and 
negative values. A vector errors containing the error values has been pre-defined for you.

    Example:
    # The errors vector has already been defined for you
    errors <- c(1.9, -2.6, 4.0, -9.5, -3.4, 7.3)

    # Sum of absolute rounded values of errors
    print(sum(abs(round(errors))))

We went ahead and pre-loaded some code for you, but there's still an error. Can you trace it and fix it?

In times of despair, help with functions such as sum() and rev() are a single command away; simply execute the 
code ?sum and ?rev.

    Example:
    # Don't edit these two lines
    vec1 <- c(1.5, 2.5, 8.4, 3.7, 6.3)
    vec2 <- rev(vec1)

    # Fix the error
    mean(c(abs(vec1), abs(vec2)))


Data Utilities
R features a bunch of functions to juggle around with data structures::

seq(): Generate sequences, by specifying the from, to, and by arguments.
rep(): Replicate elements of vectors and lists.
sort(): Sort a vector in ascending order. Works on numerics, but also on character strings and logicals.
rev(): Reverse the elements in a data structures for which reversal is defined.
str(): Display the structure of any R object.
append(): Merge vectors or lists.
is.*(): Check for the class of an R object.
as.*(): Convert an R object from one class to another.
unlist(): Flatten (possibly embedded) lists to produce a vector.
Remember the social media profile views data? Your LinkedIn and Facebook view counts for the last seven days have 
been pre-defined as lists.

    Example:
    # The linkedin and facebook lists have already been created for you
    linkedin <- list(16, 9, 13, 5, 2, 17, 14)
    facebook <- list(17, 7, 5, 16, 8, 13, 14)

    # Convert linkedin and facebook to a vector: li_vec and fb_vec
    li_vec <- unlist(linkedin)
    fb_vec <- unlist(facebook)

    # Append fb_vec to li_vec: social_vec
    social_vec <- append(li_vec, fb_vec)

    # Sort social_vec
    print(sort(social_vec, decreasing = TRUE))

Find the error (2)
Just as before, let's switch roles. It's up to you to see what unforgivable mistakes we've made. Go fix them!

    Example: 
    # Incorrect code:
    # Fix me
    seq(rep(1, 7, by = 2), times = 7)

    #Corrected Code:
    # Fix me
    rep(seq(1, 7, by = 2), times = 7)

Beat Gauss using R
There is a popular story about young Gauss. As a pupil, he had a lazy teacher who wanted to keep the classroom busy 
by having them add up the numbers 1 to 100. Gauss came up with an answer almost instantaneously, 5050. On the spot, 
he had developed a formula for calculating the sum of an arithmetic series. There are more general formulas for 
calculating the sum of an arithmetic series with different starting values and increments. Instead of deriving such 
a formula, why not use R to calculate the sum of a sequence?

    Example:
    # Create first sequence: seq1
    seq1 <- seq(1, 500, by = 3)

    # Create second sequence: seq2
    seq2 <- seq(1200, 900, by = -7)

    # Calculate total sum of the sequences
    print(sum(seq1) + sum(seq2))

#####################################################################################################################
Regular Expressions: 

grepl & grep
In their most basic form, regular expressions can be used to see whether a pattern exists inside a character string or 
a vector of character strings. For this purpose, you can use:

grepl(), which returns TRUE when a pattern is found in the corresponding character string.

grep(), which returns a vector of indices of the character strings that contains the pattern.

Both functions need a pattern and an x argument, where pattern is the regular expression you want to match for, and 
the x argument is the character vector from which matches should be sought.

In this and the following exercises, you'll be querying and manipulating a character vector of email addresses! The 
vector emails has been pre-defined so you can begin with the instructions straight away!

    Example:
    # The emails vector has already been defined for you
    emails <- c("john.doe@ivyleague.edu", "education@world.gov", "dalai.lama@peace.org",
                "invalid.edu", "quant@bigdatacollege.edu", "cookie.monster@sesame.tv")

    # Use grepl() to match for "edu"
    grepl("edu", emails)

    # Use grep() to match for "edu", save result to hits
    hits <- grep("edu", emails)

    # Subset emails using hits
    emails[hits]


grepl & grep (2)
You can use the caret, ^, and the dollar sign, $ to match the content located in the start and end of a string, 
respectively. This could take us one step closer to a correct pattern for matching only the ".edu" email addresses 
from our list of emails. But there's more that can be added to make the pattern more robust:

@, because a valid email must contain an at-sign.

.*, which matches any character (.) zero or more times (*). Both the dot and the asterisk are metacharacters. You can 
use them to match any character between the at-sign and the ".edu" portion of an email address.

\\.edu$, to match the ".edu" part of the email at the end of the string. The \\ part escapes the dot: it tells R that 
you want to use the . as an actual character.

    Example:
    # The emails vector has already been defined for you
    emails <- c("john.doe@ivyleague.edu", "education@world.gov", "dalai.lama@peace.org",
                "invalid.edu", "quant@bigdatacollege.edu", "cookie.monster@sesame.tv")

    # Use grepl() to match for .edu addresses more robustly
    print(grepl("@.*\\.edu$", emails))

    # Use grep() to match for .edu addresses more robustly, save result to hits
    hits <- grep("@.*\\.edu$", emails)

    # Subset emails using hits
    emails[hits]

sub & gsub
While grep() and grepl() were used to simply check whether a regular expression could be matched with a character 
vector, sub() and gsub() take it one step further: you can specify a replacement argument. If inside the character 
vector x, the regular expression pattern is found, the matching element(s) will be replaced with replacement. sub() 
only replaces the first match, whereas gsub() replaces all matches.

Suppose that emails vector you've been working with is an excerpt of DataCamp's email database. Why not offer the 
owners of the .edu email addresses a new email address on the datacamp.edu domain? This could be quite a powerful 
marketing stunt: Online education is taking over traditional learning institutions! Convert your email and be a part 
of the new generation!

    Example:
    # The emails vector has already been defined for you
    emails <- c("john.doe@ivyleague.edu", "education@world.gov", "global@peace.org",
                "invalid.edu", "quant@bigdatacollege.edu", "cookie.monster@sesame.tv")

    # Use sub() to convert the email domains to datacamp.edu
    print(sub("@.*\\.edu$", "@datacamp.edu", emails))

sub & gsub (2)
Regular expressions are a typical concept that you'll learn by doing and by seeing other examples. Before you rack 
your brains over the regular expression in this exercise, have a look at the new things that will be used:

.*: A usual suspect! It can be read as "any character that is matched zero or more times".
\\s: Match a space. The "s" is normally a character, escaping it (\\) makes it a metacharacter.
[0-9]+: Match the numbers 0 to 9, at least once (+).
([0-9]+): The parentheses are used to make parts of the matching string available to define the replacement. The \\1 
in the replacement argument of sub() gets set to the string that is captured by the regular expression [0-9]+.

awards <- c("Won 1 Oscar.",
  "Won 1 Oscar. Another 9 wins & 24 nominations.",
  "1 win and 2 nominations.",
  "2 wins & 3 nominations.",
  "Nominated for 2 Golden Globes. 1 more win & 2 nominations.",
  "4 wins & 1 nomination.")

sub(".*\\s([0-9]+)\\snomination.*$", "\\1", awards)

What does this code chunk return? awards is already defined in the workspace so you can start playing in the console 
straight away.

#####################################################################################################################
Times & Dates:

Right here, right now
In R, dates are represented by Date objects, while times are represented by POSIXct objects. Under the hood, however, 
these dates and times are simple numerical values. Date objects store the number of days since the 1st of January in 
1970. POSIXct objects on the other hand, store the number of seconds since the 1st of January in 1970.

The 1st of January in 1970 is the common origin for representing times and dates in a wide range of programming 
languages. There is no particular reason for this; it is a simple convention. Of course, it's also possible to create 
dates and times before 1970; the corresponding numerical values are simply negative in this case.

    Example: 
    # Get the current date: today
    today <- Sys.Date()

    # See what today looks like under the hood
    unclass(today)

    # Get the current time: now
    now <- Sys.time()

    # See what now looks like under the hood
    unclass(now)

Create and format dates
To create a Date object from a simple character string in R, you can use the as.Date() function. The character string 
has to obey a format that can be defined using a set of symbols (the examples correspond to 13 January, 1982):

%Y: 4-digit year (1982)
%y: 2-digit year (82)
%m: 2-digit month (01)
%d: 2-digit day of the month (13)
%A: weekday (Wednesday)
%a: abbreviated weekday (Wed)
%B: month (January)
%b: abbreviated month (Jan)

The following R commands will all create the same Date object for the 13th day in January of 1982:

as.Date("1982-01-13")
as.Date("Jan-13-82", format = "%b-%d-%y")
as.Date("13 January, 1982", format = "%d %B, %Y")
Notice that the first line here did not need a format argument, because by default R matches your character string to 
the formats "%Y-%m-%d" or "%Y/%m/%d".

In addition to creating dates, you can also convert dates to character strings that use a different date notation. For 
this, you use the format() function. Try the following lines of code:

today <- Sys.Date()
format(Sys.Date(), format = "%d %B, %Y")
format(Sys.Date(), format = "Today is a %A!")

    Example:
    # Definition of character strings representing dates
    str1 <- "May 23, '96"
    str2 <- "2012-03-15"
    str3 <- "30/January/2006"

    # Convert the strings to dates: date1, date2, date3
    date1 <- as.Date(str1, format = "%b %d, '%y")
    date2 <- as.Date(str2)
    date3 <- as.Date(str3, format = "%d/%B/%Y")

    # Convert dates to formatted strings
    format(date1, "%A")
    format(date2, "%d")
    format(date3, "%b %Y")

Create and format times
Similar to working with dates, you can use as.POSIXct() to convert from a character string to a POSIXct object, and 
format() to convert from a POSIXct object to a character string. Again, you have a wide variety of symbols:

%H: hours as a decimal number (00-23)
%I: hours as a decimal number (01-12)
%M: minutes as a decimal number
%S: seconds as a decimal number
%T: shorthand notation for the typical format %H:%M:%S
%p: AM/PM indicator

For a full list of conversion symbols, consult the strptime documentation in the console:

?strptime

Again,as.POSIXct() uses a default format to match character strings. In this case, it's %Y-%m-%d %H:%M:%S. In this 
exercise, abstraction is made of different time zones.

    Example:
    # Definition of character strings representing times
    str1 <- "May 23, '96 hours:23 minutes:01 seconds:45"
    str2 <- "2012-3-12 14:23:08"

    # Convert the strings to POSIXct objects: time1, time2
    time1 <- as.POSIXct(str1, format = "%B %d, '%y hours:%H minutes:%M seconds:%S")
    time2 <- as.POSIXct(str2)

    # Convert times to formatted strings
    format(time1, "%M")
    format(time2, "%I:%M %p")

Calculations with Dates
Both Date and POSIXct R objects are represented by simple numerical values under the hood. This makes calculation with 
time and date objects very straightforward: R performs the calculations using the underlying numerical values, and 
then converts the result back to human-readable time information again.

You can increment and decrement Date objects, or do actual calculations with them:

today <- Sys.Date()
today + 1
today - 1

as.Date("2015-03-12") - as.Date("2015-02-27")
To control your eating habits, you decided to write down the dates of the last five days that you ate pizza. In the 
workspace, these dates are defined as five Date objects, day1 to day5. A vector pizza containing these 5 Date objects 
has been pre-defined for you.

    Example:
    # day1, day2, day3, day4 and day5 are already available in the workspace

    # Difference between last and first pizza day
    print(as.Date(day5) - as.Date(day1))

    # Create vector pizza
    pizza <- c(day1, day2, day3, day4, day5)

    # Create differences between consecutive pizza days: day_diff
    day_diff <- diff(pizza)

    # Average period between two consecutive pizza days
    print(mean(day_diff, na.rm = TRUE))

Calculations with Times
Calculations using POSIXct objects are completely analogous to those using Date objects. Try to experiment with this 
code to increase or decrease POSIXct objects:

now <- Sys.time()
now + 3600          # add an hour
now - 3600 * 24     # subtract a day

Adding or subtracting time objects is also straightforward:

birth <- as.POSIXct("1879-03-14 14:37:23")
death <- as.POSIXct("1955-04-18 03:47:12")
einstein <- death - birth
einstein

You're developing a website that requires users to log in and out. You want to know what is the total and average 
amount of time a particular user spends on your website. This user has logged in 5 times and logged out 5 times as 
well. These times are gathered in the vectors login and logout, which are already defined in the workspace.

    Example:
    # login and logout are already defined in the workspace
    # Calculate the difference between login and logout: time_online
    time_online <- logout - login

    # Inspect the variable time_online
    print(time_online)

    # Calculate the total time online
    print(sum(time_online, na.rm = TRUE))

    # Calculate the average time online
    print(mean(time_online, na.rm = TRUE))

Time is of the essence
The dates when a season begins and ends can vary depending on who you ask. People in Australia will tell you that 
spring starts on September 1st. The Irish people in the Northern hemisphere will swear that spring starts on February 
1st, with the celebration of St. Brigid's Day. Then there's also the difference between astronomical and meteorological 
seasons: while astronomers are used to equinoxes and solstices, meteorologists divide the year into 4 fixed seasons 
that are each three months long. (source: www.timeanddate.com)

A vector astro, which contains character strings representing the dates on which the 4 astronomical seasons start, 
has been defined on your workspace. Similarly, a vector meteo has already been created for you, with the meteorological 
beginnings of a season.

    Examples:
    # Convert astro to vector of Date objects: astro_dates
    astro_dates <- as.Date(astro, format = "%d-%b-%Y")

    # Convert meteo to vector of Date objects: meteo_dates
    meteo_dates <- as.Date(meteo, format = "%B %d, %y")

    # Calculate the maximum absolute difference between astro_dates and meteo_dates
    print(max(abs(astro_dates - meteo_dates)))


