Arithmetic with R

All the normal operators apply with the addition of 

    Exponentation ^ = Raises the power of the number on the left by the number on the right

    Modulo %% = returns the remainder of the division of the number to the left by the number on the right

#######################################################################################################################
Variable assignment: 

    my_var <- 4

#######################################################################################################################
Basic Data Types in R:

    Numerics = Decimal Values like 4.5
    Intergers = whole numbers like 4
    Logical = TRUE/FALSE                        # Note that these are always in all CAPS
    characters = text / string

########################################################################################################################
Checking the Data Type: 

    class() = will check what data type a variable Intergers

########################################################################################################################
Create a Vector:

    A vector is a 1D array that can hold numeric, character, or logical data

    c() = is the command to create a vector, place the elements between the () separated by comas

    example: 
        numeric_vector = c(1,2,3)
        character_vector = c("a", "b", "c")
        boolean_vector = c(TRUE, FALSE, TRUE)

###########################################################################################################################
Naming a Vector: 

    names() = the command to name a vector

    example: names each element in roulette_vector with a corisponding day of the week
        roulette_vector <- c(-24, -50, 100, -350, 10)
        names(roulette_vector) <- c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday") # you can also assign the days of the week to a variable and use it

#############################################################################################################################
Calculate Total Winnings:

    sum() = calculates the sum of all elements in a vector

    example:
        total_poker <- sum(poker_vector)

#############################################################################################################################
Selecting Elements in a Vector:

    example:
    # It seems that R indexes start from 1 not 0
    my_vector[1]

    example: 
    # selects the first and fifth elements
    poker_vector[c(1,5)]

    example: 
    # selects elements 2-4 including 4
    poker_vector[c(2:4)]

    example: 
    # if you have named your elements you can select them by name
    poker_vector[c("Monday", "Tuesday")]

##########################################################################################################################
Calculating The average of values

    mean() = calculates the average of the the values given to it

    example:
    poker_start <- poker_vector[c("Monday", "Tuesday", "Wednesday")
    mean(poker_start)]

##########################################################################################################################
Comparison operators

    < = less than
    > = Greater than
    <= = Less than or equal to 
    >= = Greater than or equal to 
    == = equal to each other
    != = Not equal to each other

    example:
    selection_vector <- poker_vector > 0    # creates a boolean array
    poker_winning_days <- poker_vector[selection_vector]    # This will only select elements that are true and assign the values

###########################################################################################################################
Advanced Selection:

    example:
    selection_vector <- roulette_vector > 0
    roulette_winning_days <- roulette_vector[selection_vector]

###########################################################################################################################
Matrix:

    matrix() = collection of elements of the same data type arranged in a fixed number of rows and columns which is a 2D array

    example:
    # 1:9 is shortcut for making a vector with content 1-9
    # byrow = TRUE means the martix will be filled by row if you want to fill by column then set to FALSE
    # nrow = 3 sets the row count to 3 
    matrix(1:9, byrow = True, nrow = 3)

Analyzing Matrices:

###########################################################################################################################
Factors:

    The term factor refers to a statistical data type used to store categorical variables. The difference between a categorical variable and a continuous variable is that a categorical variable can belong to a limited number of categories. A continuous variable, on the other hand, can correspond to an infinite number of values.

It is important that R knows whether it is dealing with a continuous or a categorical variable, as the statistical models you will develop in the future treat both types differently. (You will see later why this is the case.)

A good example of a categorical variable is sex. In many circumstances you can limit the sex categories to "Male" or "Female".
 (Sometimes you may need different categories. For example, you may need to consider chromosomal variation, hermaphroditic 
 animals, or different cultural norms, but you will always have a finite number of categories.)

 To create factors in R, you make use of the function factor(). First thing that you have to do is create a vector that 
 contains all the observations that belong to a limited number of categories. For example, sex_vector contains the sex of 5 
 different individuals:

sex_vector <- c("Male","Female","Female","Male","Male")
It is clear that there are two categories, or in R-terms 'factor levels', at work here: "Male" and "Female".

The function factor() will encode the vector as a factor:

factor_sex_vector <- factor(sex_vector)

What's a factor and why would you use it? (3)
There are two types of categorical variables: a nominal categorical variable and an ordinal categorical variable.

A nominal variable is a categorical variable without an implied order. This means that it is impossible to say that 
'one is worth more than the other'. For example, think of the categorical variable animals_vector with the categories 
"Elephant", "Giraffe", "Donkey" and "Horse". Here, it is impossible to say that one stands above or below the other. 
(Note that some of you might disagree ;-) ).

In contrast, ordinal variables do have a natural ordering. Consider for example the categorical variable temperature_vector 
with the categories: "Low", "Medium" and "High". Here it is obvious that "Medium" stands above "Low", and "High" stands 
above "Medium".

Factor levels
When you first get a dataset, you will often notice that it contains factors with specific factor levels. However, 
sometimes you will want to change the names of these levels for clarity or other reasons. R allows you to do this with the 
function levels():

levels(factor_vector) <- c("name1", "name2",...)

A good illustration is the raw data that is provided to you by a survey. A common question for every questionnaire is the 
sex of the respondent. Here, for simplicity, just two categories were recorded, "M" and "F". (You usually need more categories
 for survey data; either way, you use a factor to store the categorical data.)

survey_vector <- c("M", "F", "F", "M", "M")

Recording the sex with the abbreviations "M" and "F" can be convenient if you are collecting data with pen and paper, 
but it can introduce confusion when analyzing the data. At that point, you will often want to change the factor levels to 
"Male" and "Female" instead of "M" and "F" for clarity.

Watch out: the order with which you assign the levels is important. If you type levels(factor_survey_vector), you'll see 
that it outputs [1] "F" "M". If you don't specify the levels of the factor when creating the vector, R will automatically 
assign them alphabetically. To correctly map "F" to "Female" and "M" to "Male", the levels should be set to 
c("Female", "Male"), in this order.

Summarizing a factor
After finishing this course, one of your favorite functions in R will be summary(). This will give you a quick overview 
of the contents of a variable:

summary(my_var)

Going back to our survey, you would like to know how many "Male" responses you have in your study, and how many 
"Female" responses. The summary() function gives you the answer to this question.

You might wonder what happens when you try to compare elements of a factor. In factor_survey_vector you have a factor
 with two levels: "Male" and "Female". But how does R value these relative to each other?

 example:
    # Read the code in the editor and submit the answer to test if male is greater than (>) female.

    # Build factor_survey_vector with clean levels
    survey_vector <- c("M", "F", "F", "M", "M")
    factor_survey_vector <- factor(survey_vector)
    levels(factor_survey_vector) <- c("Female", "Male")

    # Male
    male <- factor_survey_vector[1]

    # Female
    female <- factor_survey_vector[2]

    # Battle of the sexes: Male 'larger' than female?
    male > female

Ordered Factors: 

Since "Male" and "Female" are unordered (or nominal) factor levels, R returns a warning message, telling you that the 
greater than operator is not meaningful. As seen before, R attaches an equal value to the levels for such factors.

But this is not always the case! Sometimes you will also deal with factors that do have a natural ordering between its 
categories. If this is the case, we have to make sure that we pass this information to R…

Let us say that you are leading a research team of five data analysts and that you want to evaluate their performance. 
To do this, you track their speed, evaluate each analyst as "slow", "medium" or "fast", and save the results in 
speed_vector.

speed_vector should be converted to an ordinal factor since its categories have a natural ordering. By default, the 
function factor() transforms speed_vector into an unordered factor. To create an ordered factor, you have to add two 
additional arguments: ordered and levels.

factor(some_vector,
       ordered = TRUE,
       levels = c("lev1", "lev2" ...))

By setting the argument ordered to TRUE in the function factor(), you indicate that the factor is ordered. With the
 argument levels you give the values of the factor in the correct order.

    example: 
    # Create speed_vector
    speed_vector <- c("medium", "slow", "slow", "medium", "fast")

    # Convert speed_vector to ordered factor vector
    factor_speed_vector <- factor(speed_vector, ordered = TRUE, c("slow", "medium", "fast"))

    # Print factor_speed_vector
    factor_speed_vector
    summary(factor_speed_vector)

Comparing ordered factors
Having a bad day at work, 'data analyst number two' enters your office and starts complaining that 'data analyst number five' 
is slowing down the entire project. Since you know that 'data analyst number two' has the reputation of being a smarty-pants, 
you first decide to check if his statement is true.

The fact that factor_speed_vector is now ordered enables us to compare different elements (the data analysts in this case). 
You can simply do this by using the well-known operators.

    example:
    # Create factor_speed_vector
    speed_vector <- c("medium", "slow", "slow", "medium", "fast")
    factor_speed_vector <- factor(speed_vector, ordered = TRUE, levels = c("slow", "medium", "fast"))

    # Factor value for second data analyst
    da2 <- factor_speed_vector[2]

    # Factor value for fifth data analyst
    da5 <- factor_speed_vector[5]

    # Is data analyst 2 faster than data analyst 5?
    da2 > da5

###########################################################################################################################
Dataframes:

What's a data frame?
You may remember from the chapter about matrices that all the elements that you put in a matrix should be of the same type. 
Back then, your dataset on Star Wars only contained numeric elements.

When doing a market research survey, however, you often have questions such as:

'Are you married?' or 'yes/no' questions (logical)
'How old are you?' (numeric)
'What is your opinion on this product?' or other 'open-ended' questions (character)
…
The output, namely the respondents' answers to the questions formulated above, is a dataset of different data types. You will 
often find yourself working with datasets that contain different data types instead of only one.

A data frame has the variables of a dataset as columns and the observations as rows. This will be a familiar concept for 
those coming from different statistical software packages such as SAS or SPSS.

Quick, have a look at your dataset
Wow, that is a lot of cars!

Working with large datasets is not uncommon in data analysis. When you work with (extremely) large datasets and data frames, 
your first task as a data analyst is to develop a clear understanding of its structure and main elements. Therefore, it is 
often useful to show only a small part of the entire dataset.

So how to do this in R? Well, the function head() enables you to show the first observations of a data frame. Similarly, the 
function tail() prints out the last observations in your dataset.

Both head() and tail() print a top line called the 'header', which contains the names of the different variables in your 
dataset.

Have a look at the structure
Another method that is often used to get a rapid overview of your data is the function str(). The function str() shows you 
the structure of your dataset. For a data frame it tells you:

The total number of observations (e.g. 32 car types)
The total number of variables (e.g. 11 car features)
A full list of the variables names (e.g. mpg, cyl … )
The data type of each variable (e.g. num)
The first observations
Applying the str() function will often be the first thing that you do when receiving a new dataset or data frame. It is a
great way to get more insight in your dataset before diving into the real analysis.

Creating a data frame
Since using built-in datasets is not even half the fun of creating your own datasets, the rest of this chapter is based on 
your personally developed dataset. Put your jet pack on because it is time for some space exploration!

As a first goal, you want to construct a data frame that describes the main characteristics of eight planets in our solar 
system. According to your good friend Buzz, the main features of a planet are:

The type of planet (Terrestrial or Gas Giant).
The planet's diameter relative to the diameter of the Earth.
The planet's rotation across the sun relative to that of the Earth.
If the planet has rings or not (TRUE or FALSE).
After doing some high-quality research on Wikipedia, you feel confident enough to create the necessary vectors: name, type, 
diameter, rotation and rings; these vectors have already been coded up in the editor. The first element in each of these 
vectors correspond to the first observation.

You construct a data frame with the data.frame() function. As arguments, you pass the vectors from before: they will become 
the different columns of your data frame. Because every column has the same length, the vectors you pass should also have the 
same length. But don't forget that it is possible (and likely) that they contain different types of data.

    Example:
    # Definition of vectors
    name <- c("Mercury", "Venus", "Earth", 
            "Mars", "Jupiter", "Saturn", 
            "Uranus", "Neptune")
    type <- c("Terrestrial planet", 
            "Terrestrial planet", 
            "Terrestrial planet", 
            "Terrestrial planet", "Gas giant", 
            "Gas giant", "Gas giant", "Gas giant")
    diameter <- c(0.382, 0.949, 1, 0.532, 
                11.209, 9.449, 4.007, 3.883)
    rotation <- c(58.64, -243.02, 1, 1.03, 
                0.41, 0.43, -0.72, 0.67)
    rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

    # Create a data frame from the vectors
    planets_df <- data.frame(name, type, diameter, rotation, rings)

Selection of data frame elements
Similar to vectors and matrices, you select elements from a data frame with the help of square brackets [ ]. By using a 
comma, you can indicate what to select from the rows and the columns respectively. For example:

my_df[1,2] selects the value at the first row and second column in my_df.
my_df[1:3,2:4] selects rows 1, 2, 3 and columns 2, 3, 4 in my_df.

Sometimes you want to select all elements of a row or column. For example, my_df[1, ] selects all elements of the first row. 
Let us now apply this technique on planets_df!

    Example:
    # The planets_df data frame from the previous exercise is pre-loaded

    # Print out diameter of Mercury (row 1, column 3)
    planets_df[1,3]

    # Print out data for Mars (entire fourth row)
    planets_df[4,]

Selection of data frame elements (2)
Instead of using numerics to select elements of a data frame, you can also use the variable names to select columns of a 
data frame.

Suppose you want to select the first three elements of the type column. One way to do this is

planets_df[1:3,2]

A possible disadvantage of this approach is that you have to know (or look up) the column number of type, which gets hard if 
you have a lot of variables. It is often easier to just make use of the variable name:

planets_df[1:3,"type"]

    Example:
    # The planets_df data frame from the previous exercise is pre-loaded

    # Select first 5 values of diameter column
    planets_df[1:5, "diameter"]

Only planets with rings
You will often want to select an entire column, namely one specific variable from a data frame. If you want to select all 
elements of the variable diameter, for example, both of these will do the trick:

planets_df[,3]
planets_df[,"diameter"]

However, there is a short-cut. If your columns have names, you can use the $ sign:

planets_df$diameter

    Example:
    # planets_df is pre-loaded in your workspace

    # Select the rings variable from planets_df
    rings_vector <- planets_df$rings
    
    # Print out rings_vector
    rings_vector

Only planets with rings (2)
You probably remember from high school that some planets in our solar system have rings and others do not. Unfortunately you 
can not recall their names. Could R help you out?

If you type rings_vector in the console, you get:

[1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE

This means that the first four observations (or planets) do not have a ring (FALSE), but the other four do (TRUE). However, 
you do not get a nice overview of the names of these planets, their diameter, etc. Let's try to use rings_vector to select 
the data for the four planets with rings.

    Example:
    # planets_df and rings_vector are pre-loaded in your workspace

    # Adapt the code to select all columns for planets with rings
    planets_df[rings_vector, ]

Only planets with rings but shorter
So what exactly did you learn in the previous exercises? You selected a subset from a data frame (planets_df) based on 
whether or not a certain condition was true (rings or no rings), and you managed to pull out all relevant data. Pretty 
awesome! By now, NASA is probably already flirting with your CV ;-).

Now, let us move up one level and use the function subset(). You should see the subset() function as a short-cut to do 
exactly the same as what you did in the previous exercises.

subset(my_df, subset = some_condition)

The first argument of subset() specifies the dataset for which you want a subset. By adding the second argument, you give R 
the necessary information and conditions to select the correct subset.

The code below will give the exact same result as you got in the previous exercise, but this time, you didn't need the 
rings_vector!

subset(planets_df, subset = rings)

    Example:
    # planets_df is pre-loaded in your workspace

    # Select planets with diameter < 1
    subset(planets_df, subset = diameter < 1)

###########################################################################################################################
Sorting: 

Making and creating rankings is one of mankind's favorite affairs. These rankings can be useful (best universities in the 
world), entertaining (most influential movie stars) or pointless (best 007 look-a-like).

In data analysis you can sort your data according to a certain variable in the dataset. In R, this is done with the help of 
the function order().

order() is a function that gives you the ranked position of each element when it is applied on a variable, such as a vector 
for example:

a <- c(100, 10, 1000)
order(a)
[1] 2 1 3

10, which is the second element in a, is the smallest element, so 2 comes first in the output of order(a). 100, which is the 
first element in a is the second smallest element, so 1 comes second in the output of order(a).

This means we can use the output of order(a) to reshuffle a:

a[order(a)]
[1]   10  100 1000

Sorting your data frame
Alright, now that you understand the order() function, let us do something useful with it. You would like to rearrange your 
data frame such that it starts with the smallest planet and ends with the largest one. A sort on the diameter column.

    Example: 
    # planets_df is pre-loaded in your workspace

    # Use order() to create positions
    positions <-  order(planets_df$diameter)

    # Use positions to sort planets_df
    planets_df[positions,]

########################################################################################################################
Lists:

Lists, why would you need them?
Congratulations! At this point in the course you are already familiar with:

Vectors (one dimensional array): can hold numeric, character or logical values. The elements in a vector all have the same 
data type.
Matrices (two dimensional array): can hold numeric, character or logical values. The elements in a matrix all have the same 
data type.
Data frames (two-dimensional objects): can hold numeric, character or logical values. Within a column all elements have the 
same data type, but different columns can be of different data type.

Pretty sweet for an R newbie, right? ;-)

Lists, why would you need them? (2)
A list in R is similar to your to-do list at work or school: the different items on that list most likely differ in length, 
characteristic, and type of activity that has to be done.

A list in R allows you to gather a variety of objects under one name (that is, the name of the list) in an ordered way. These 
objects can be matrices, vectors, data frames, even other lists, etc. It is not even required that these objects are related 
to each other in any way.

You could say that a list is some kind super data type: you can store practically any piece of information in it!

Creating a list
Let us create our first list! To construct a list you use the function list():

my_list <- list(comp1, comp2 ...)

The arguments to the list function are the list components. Remember, these components can be matrices, vectors, other lists, …

    Example:
    # Vector with numerics from 1 up to 10
    my_vector <- 1:10 

    # Matrix with numerics from 1 up to 9
    my_matrix <- matrix(1:9, ncol = 3)

    # First 10 elements of the built-in data frame mtcars
    my_df <- mtcars[1:10,]

    # Construct list with these different elements:
    my_list <- list(my_vector, my_matrix, my_df)

Creating a named list
Well done, you're on a roll!

Just like on your to-do list, you want to avoid not knowing or remembering what the components of your list stand for. 
That is why you should give names to them:

my_list <- list(name1 = your_comp1, 
                name2 = your_comp2)

This creates a list with components that are named name1, name2, and so on. If you want to name your lists after you've 
created them, you can use the names() function as you did with vectors. The following commands are fully equivalent to the 
assignment above:

my_list <- list(your_comp1, your_comp2)
names(my_list) <- c("name1", "name2")

    Example: 
    # Vector with numerics from 1 up to 10
    my_vector <- 1:10 

    # Matrix with numerics from 1 up to 9
    my_matrix <- matrix(1:9, ncol = 3)

    # First 10 elements of the built-in data frame mtcars
    my_df <- mtcars[1:10,]

    # Adapt list() call to give the components names
    my_list <- list("vec" = my_vector, "mat" = my_matrix, "df" =my_df)


    # Print out my_list
    my_list

Creating a named list (2)
Being a huge movie fan (remember your job at LucasFilms), you decide to start storing information on good movies with the 
help of lists.

Start by creating a list for the movie "The Shining". We have already created the variables mov, act and rev in your R 
workspace. Feel free to check them out in the console.

    Example:
    # The variables mov, act and rev are available

    # Finish the code to build shining_list
    shining_list <- list(moviename = mov, actors = act, reviews = rev)

Selecting elements from a list
Your list will often be built out of numerous elements and components. Therefore, getting a single element, multiple 
elements, or a component out of it is not always straightforward.

One way to select a component is using the numbered position of that component. For example, to "grab" the first component 
of shining_list you type

shining_list[[1]]

A quick way to check this out is typing it in the console. Important to remember: to select elements from vectors, you use 
single square brackets: [ ]. Don't mix them up!

You can also refer to the names of the components, with [[ ]] or with the $ sign. Both will select the data frame 
representing the reviews:

shining_list[["reviews"]]
shining_list$reviews
Besides selecting components, you often need to select specific elements out of these components. For example, with 
shining_list[[2]][1] you select from the second component, actors (shining_list[[2]]), the first element ([1]). When 
you type this in the console, you will see the answer is Jack Nicholson.

    Example:
    # shining_list is already pre-loaded in the workspace

    # Print out the vector representing the actors
    shining_list$actors

    # Print the second element of the vector representing the actors
    shining_list[[2]][2]

Creating a new list for another movie
You found reviews of another, more recent, Jack Nicholson movie: The Departed!

Scores	        Comments
4.6	            I would watch it again
5	            Amazing!
4.8	            I liked it
5	            One of the best movies
4.2	            Fascinating plot

It would be useful to collect together all the pieces of information about the movie, like the title, actors, and reviews 
into a single variable. Since these pieces of data are different shapes, it is natural to combine them in a list variable.

movie_title, containing the title of the movie, and movie_actors, containing the names of some of the actors in the movie, 
are available in your workspace.

    Example:
    # Use the table from the exercise to define the comments and scores vectors
    scores <- c(4.6, 5, 4.8, 5, 4.2)
    comments <- c("I would watch it again", "Amazing!", "I liked it", "One of the best movies", "Fascinating plot")

    # Save the average of the scores vector as avg_review
    avg_review <- mean(scores)

    # Combine scores and comments into the reviews_df data frame
    reviews_df <- data.frame(scores, comments)

    # Create and print out a list, called departed_list
    departed_list <- list(movie_title, movie_actors, reviews_df, avg_review)
    departed_list

##########################################################################################################################
Functions:

Before even thinking of using an R function, you should clarify which arguments it expects. All the relevant details such 
as a description, usage, and arguments can be found in the documentation. To consult the documentation on the sample() 
function, for example, you can use one of following R commands:

help(sample)

?sample

If you execute these commands, you'll be redirected to www.rdocumentation.org.

A quick hack to see the arguments of the sample() function is the args() function. Try it out in the console:

args(sample)
In the next exercises, you'll be learning how to use the mean() function with increasing complexity. The first thing you'll 
have to do is get acquainted with the mean() function.

    Example:
    # Consult the documentation on the mean() function
    ?mean

    # Inspect the arguments of the mean() function
    args(mean)

Use a function
The documentation on the mean() function gives us quite some information:

The mean() function computes the arithmetic mean.
The most general method takes multiple arguments: x and ....
The x argument should be a vector containing numeric, logical or time-related information.
Remember that R can match arguments both by position and by name. Can you still remember the difference? You'll find out 
in this exercise!

Once more, you'll be working with the view counts of your social network profiles for the past 7 days. These are stored 
in the linkedin and facebook vectors and have already been created for you.

    Example:
    # The linkedin and facebook vectors have already been created for you
    linkedin <- c(16, 9, 13, 5, 2, 17, 14)
    facebook <- c(17, 7, 5, 16, 8, 13, 14)

    # Calculate average number of views
    avg_li <- mean(linkedin)
    avg_fb <- mean(facebook)

    # Inspect avg_li and avg_fb
    print(avg_li)
    print(avg_fb)

Use a function (2)
Check the documentation on the mean() function again:

?mean
The Usage section of the documentation includes two versions of the mean() function. The first usage,

mean(x, ...)
is the most general usage of the mean function. The 'Default S3 method', however, is:

mean(x, trim = 0, na.rm = FALSE, ...)
The ... is called the ellipsis. It is a way for R to pass arguments along without the function having to name them explicitly. 
The ellipsis will be treated in more detail in future courses.

For the remainder of this exercise, just work with the second usage of the mean function. Notice that both trim and na.rm 
have default values. This makes them optional arguments.

    Example:
    # The linkedin and facebook vectors have already been created for you
    linkedin <- c(16, 9, 13, 5, 2, 17, 14)
    facebook <- c(17, 7, 5, 16, 8, 13, 14)

    # Calculate the mean of the sum
    avg_sum <- mean(linkedin + facebook)

    # Calculate the trimmed mean of the sum
    avg_sum_trimmed <- mean(linkedin + facebook, trim = 0.2)

    # Inspect both new variables
    print(avg_sum)
    print(avg_sum_trimmed)

Use a function (3)
In the video, Filip guided you through the example of specifying arguments of the sd() function. The sd() function has an 
optional argument, na.rm that specified whether or not to remove missing values from the input vector before calculating 
the standard deviation.

If you've had a good look at the documentation, you'll know by now that the mean() function also has this argument, na.rm, 
and it does the exact same thing. By default, it is set to FALSE, as the Usage of the default S3 method shows:

mean(x, trim = 0, na.rm = FALSE, ...)

Let's see what happens if your vectors linkedin and facebook contain missing values (NA).

    Example:
    # The linkedin and facebook vectors have already been created for you
    linkedin <- c(16, 9, 13, 5, NA, 17, 14)
    facebook <- c(17, NA, 5, 16, 8, 13, 14)

    # Basic average of linkedin
    mean(linkedin)

    # Advanced average of linkedin
    mean(linkedin, na.rm = TRUE)

Functions inside functions
You already know that R functions return objects that you can then use somewhere else. This makes it easy to use functions 
inside functions, as you've seen before:

speed <- 31
print(paste("Your speed is", speed))

Notice that both the print() and paste() functions use the ellipsis - ... - as an argument. Can you figure out how they're 
used?

    Example:
    # The linkedin and facebook vectors have already been created for you
    linkedin <- c(16, 9, 13, 5, NA, 17, 14)
    facebook <- c(17, NA, 5, 16, 8, 13, 14)

    # Calculate the mean absolute deviation
    mean(abs(linkedin - facebook), na.rm = TRUE)

Required, or optional?
By now, you will probably have a good understanding of the difference between required and optional arguments. Let's refresh 
this difference by having one last look at the mean() function:

mean(x, trim = 0, na.rm = FALSE, ...)

x is required; if you do not specify it, R will throw an error. trim and na.rm are optional arguments: they have a default value which is used if the arguments are not explicitly specified.

Which of the following statements about the read.table() function are true?

header, sep and quote are all optional arguments.
row.names and fileEncoding don't have default values.
read.table("myfile.txt", "-", TRUE) will throw an error.
read.table("myfile.txt", sep = "-", header = TRUE) will throw an error.

##########################################################################################################################
Writing Functions: 

Syntax:
my_function <- function(art1, arg2) {
    body of the function
}

Write your own function
Wow, things are getting serious… you're about to write your own function! Before you have a go at it, have a look at the 
following function template:

my_fun <- function(arg1, arg2) {
  body
}

Notice that this recipe uses the assignment operator (<-) just as if you were assigning a vector to a variable for example. 
This is not a coincidence. Creating a function in R basically is the assignment of a function object to a variable! In the 
recipe above, you're creating a new R variable my_fun, that becomes available in the workspace as soon as you execute the 
definition. From then on, you can use the my_fun as a function.

    Example:
    # Create a function pow_two()
    pow_two <- function(a) {
        a * a
    }


    # Use the function
    pow_two(12)

    # Create a function sum_abs()
    sum_abs <- function(a,b){
        abs(a) + abs(b)
    }


    # Use the function
    sum_abs(-2, 3)

Write your own function (2)
There are situations in which your function does not require an input. Let's say you want to write a function that gives us 
the random outcome of throwing a fair die:

throw_die <- function() {
  number <- sample(1:6, size = 1)
  number
}

throw_die()

Up to you to code a function that doesn't take any arguments!

    Example:
    # Define the function hello()
    hello <- function(){
        print("Hi there!")
        return(TRUE)
    }




    # Call the function hello()
    hello()

Write your own function (3)
Do you still remember the difference between an argument with and without default values? The usage section in the sd() 
documentation shows the following information:

sd(x, na.rm = FALSE)

This tells us that x has to be defined for the sd() function to be called correctly, however, na.rm already has a default 
value. Not specifying this argument won't cause an error.

You can define default argument values in your own R functions as well. You can use the following recipe to do so:

my_fun <- function(arg1, arg2 = val2) {
  body
}

The editor on the right already includes an extended version of the pow_two() function from before. Can you finish it?

    Example: 
    # Finish the pow_two() function
    pow_two <- function(x, print_info = TRUE) {
    y <- x ^ 2
    if(print_info == TRUE){
        print(paste(x, "to the power two equals", y))
    }
    return(y)
    }

Function scoping
An issue that Filip did not discuss in the video is function scoping. It implies that variables that are defined inside a function are not accessible outside that function. Try running the following code and see if you understand the results:

pow_two <- function(x) {
  y <- x ^ 2
  return(y)
}
pow_two(4)
y
x

y was defined inside the pow_two() function and therefore it is not accessible outside of that function. This is also true 
for the function's arguments of course - x in this case.

Which statement is correct about the following chunk of code? The function two_dice() is already available in the workspace.

two_dice <- function() {
  possibilities <- 1:6
  dice1 <- sample(possibilities, size = 1)
  dice2 <- sample(possibilities, size = 1)
  dice1 + dice2
}

R passes arguments by value
The title gives it away already: R passes arguments by value. What does this mean? Simply put, it means that an R function 
cannot change the variable that you input to that function. Let's look at a simple example (try it in the console):

triple <- function(x) {
  x <- 3*x
  x
}
a <- 5
triple(a)
a

Inside the triple() function, the argument x gets overwritten with its value times three. Afterwards this new x is returned. 
If you call this function with a variable a set equal to 5, you obtain 15. But did the value of a change? If R were to pass a 
to triple() by reference, the override of the x inside the function would ripple through to the variable a, outside the 
function. However, R passes by value, so the R objects you pass to a function can never change unless you do an explicit 
assignment. a remains equal to 5, even after calling triple(a).

Can you tell which one of the following statements is false about the following piece of code?

increment <- function(x, inc = 1) {
  x <- x + inc
  x
}
count <- 5
a <- increment(count, 2)
b <- increment(count)
count <- increment(count, 2)

R you functional?
Now that you've acquired some skills in defining functions with different types of arguments and return values, you should 
try to create more advanced functions. As you've noticed in the previous exercises, it's perfectly possible to add 
control-flow constructs, loops and even other functions to your function body.

Remember our social media example? The vectors linkedin and facebook are already defined in the workspace so you can get your 
hands dirty straight away. As a first step, you will be writing a function that can interpret a single value of this vector. 
In the next exercise, you will write another function that can handle an entire vector at once.

    Example:
    # The linkedin and facebook vectors have already been created for you

    # Define the interpret function
    interpret <- function(num_views) {
        if (num_views > 15) {
            print("You're popular!")
            return(num_views)
        } else {
            print("Try to be more visible!")
            return(0)
        }
    }

    # Call the interpret function twice
    interpret(linkedin[1])
    interpret(facebook[2])

R you functional? (2)
A possible implementation of the interpret() function has been provided for you. In this exercise you'll be writing another 
function that will use the interpret() function to interpret all the data from your daily profile views inside a vector. 
Furthermore, your function will return the sum of views on popular days, if asked for. A for loop is ideal for iterating 
over all the vector elements. The ability to return the sum of views on popular days is something you can code through a 
function argument with a default value.

    Example:
    # The linkedin and facebook vectors have already been created for you
    linkedin <- c(16, 9, 13, 5, 2, 17, 14)
    facebook <- c(17, 7, 5, 16, 8, 13, 14)

    # The interpret() can be used inside interpret_all()
    interpret <- function(num_views) {
        if (num_views > 15) {
            print("You're popular!")
            return(num_views)
        } else {
            print("Try to be more visible!")
            return(0)
        }
    }

    # Define the interpret_all() function
    # views: vector with data to interpret
    # return_sum: return total number of views on popular days?
    interpret_all <- function(views, return_sum = TRUE) {
        count <- 0

        for (v in views) {
            count = count + interpret(v)
        }

        if (return_sum == TRUE) {
            return(count)
        } else {
            return(NULL)
        }
    }

    # Call the interpret_all() function on both linkedin and facebook
    interpret_all(linkedin)
    interpret_all(facebook)

##########################################################################################################################
R Packages:

Load an R Package
There are basically two extremely important functions when it comes down to R packages:

install.packages(), which as you can expect, installs a given package.
library() which loads packages, i.e. attaches them to the search list on your R workspace.
To install packages, you need administrator privileges. This means that install.packages() will thus not work in the 
DataCamp interface. However, almost all CRAN packages are installed on our servers. You can load them with library().

In this exercise, you'll be learning how to load the ggplot2 package, a powerful package for data visualization. You'll 
use it to create a plot of two variables of the mtcars data frame. The data has already been prepared for you in the 
workspace.

Before starting, execute the following commands in the console:

search(), to look at the currently attached packages and
qplot(mtcars$wt, mtcars$hp), to build a plot of two variables of the mtcars data frame.
An error should occur, because you haven't loaded the ggplot2 package yet!

    Example:
    # Load the ggplot2 package
    library(ggplot2)

    # Retry the qplot() function
    qplot(mtcars$wt, mtcars$hp)

    # Check out the currently attached packages again
    search()

Different ways to load a package
The library() and require() functions are not very picky when it comes down to argument types: both library(rjson) and 
library("rjson") work perfectly fine for loading a package.

Have a look at some more code chunks that (attempt to) load one or more packages:

# Chunk 1
library(data.table)
require(rjson)

# Chunk 2
library("data.table")
require(rjson)

# Chunk 3
library(data.table)
require(rjson, character.only = TRUE)

# Chunk 4
library(c("data.table", "rjson"))
Select the option that lists all of the chunks that do not generate an error. The console is yours to experiment in.


